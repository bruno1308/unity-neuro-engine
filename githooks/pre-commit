#!/bin/bash
#
# Pre-commit hook for Neuro-Engine
# Enforces code-reviewer-layers agent approval for engine infrastructure changes
#
# Install: git config core.hooksPath githooks
#

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Protected paths that require layer review
PROTECTED_PATHS=(
    "Packages/com.neuroengine.core/Runtime/Core/"
    "Packages/com.neuroengine.core/Runtime/Services/"
    "Packages/com.neuroengine.core/Editor/"
    "Packages/com.neuroengine.core/Tests/"
)

# Get staged files
STAGED_FILES=$(git diff --cached --name-only --diff-filter=ACMR)

if [ -z "$STAGED_FILES" ]; then
    exit 0
fi

# Check if any protected paths are affected
PROTECTED_CHANGES=()
for file in $STAGED_FILES; do
    for path in "${PROTECTED_PATHS[@]}"; do
        if [[ "$file" == $path* ]]; then
            PROTECTED_CHANGES+=("$file")
            break
        fi
    done
done

# If no protected files, allow commit
if [ ${#PROTECTED_CHANGES[@]} -eq 0 ]; then
    exit 0
fi

echo -e "${BLUE}========================================${NC}"
echo -e "${YELLOW}ENGINE LAYER REVIEW REQUIRED${NC}"
echo -e "${BLUE}========================================${NC}"
echo ""
echo -e "The following protected files are staged:"
echo ""
for file in "${PROTECTED_CHANGES[@]}"; do
    echo -e "  ${YELLOW}$file${NC}"
done
echo ""

# Check for anti-patterns in staged changes
echo -e "${BLUE}Running anti-pattern checks...${NC}"
echo ""

ERRORS=0
WARNINGS=0

# Layer 1: Check for hidden dependencies
echo -n "  Layer 1 - Hidden dependencies: "
HIDDEN_DEPS=$(git diff --cached -G "GetComponent<|FindObjectOfType<" -- "${PROTECTED_CHANGES[@]}" 2>/dev/null | grep -E "^\+" | grep -v "^+++" || true)
if [ -n "$HIDDEN_DEPS" ]; then
    echo -e "${RED}FAILED${NC}"
    echo -e "    ${RED}Found GetComponent<> or FindObjectOfType<> usage${NC}"
    echo -e "    ${YELLOW}Use VContainer dependency injection instead${NC}"
    ERRORS=$((ERRORS + 1))
else
    echo -e "${GREEN}PASSED${NC}"
fi

# Layer 2: Check for mutation in observation code
echo -n "  Layer 2 - Observation purity: "
OBSERVATION_FILES=$(echo "${PROTECTED_CHANGES[@]}" | tr ' ' '\n' | grep -E "(Capture|Detector|Analysis)" || true)
if [ -n "$OBSERVATION_FILES" ]; then
    MUTATIONS=$(git diff --cached -G "SetActive|Destroy\(|Instantiate\(" -- $OBSERVATION_FILES 2>/dev/null | grep -E "^\+" | grep -v "^+++" || true)
    if [ -n "$MUTATIONS" ]; then
        echo -e "${RED}FAILED${NC}"
        echo -e "    ${RED}Found mutation (SetActive/Destroy/Instantiate) in observation code${NC}"
        echo -e "    ${YELLOW}Observation code must be read-only${NC}"
        ERRORS=$((ERRORS + 1))
    else
        echo -e "${GREEN}PASSED${NC}"
    fi
else
    echo -e "${GREEN}SKIPPED (no observation files)${NC}"
fi

# Layer 4: Check for non-atomic writes
echo -n "  Layer 4 - Atomic writes: "
WRITER_FILES=$(echo "${PROTECTED_CHANGES[@]}" | tr ' ' '\n' | grep -E "Writer" || true)
if [ -n "$WRITER_FILES" ]; then
    # Check if WriteAllText is used without .tmp pattern nearby
    NONATOMIC=$(git diff --cached -- $WRITER_FILES 2>/dev/null | grep -E "^\+.*WriteAllText" | grep -v "\.tmp" || true)
    if [ -n "$NONATOMIC" ]; then
        echo -e "${YELLOW}WARNING${NC}"
        echo -e "    ${YELLOW}File.WriteAllText without atomic pattern detected${NC}"
        echo -e "    ${YELLOW}Consider: write to .tmp then File.Move${NC}"
        WARNINGS=$((WARNINGS + 1))
    else
        echo -e "${GREEN}PASSED${NC}"
    fi
else
    echo -e "${GREEN}SKIPPED (no writer files)${NC}"
fi

# Check for hardcoded API keys
echo -n "  Security - Hardcoded secrets: "
SECRETS=$(git diff --cached -- "${PROTECTED_CHANGES[@]}" 2>/dev/null | grep -E "^\+.*(api_key|apikey|secret|password)\s*=\s*['\"][^'\"]+['\"]" -i || true)
if [ -n "$SECRETS" ]; then
    echo -e "${RED}FAILED${NC}"
    echo -e "    ${RED}Possible hardcoded secret detected${NC}"
    echo -e "    ${YELLOW}Use IEnvConfig for API keys${NC}"
    ERRORS=$((ERRORS + 1))
else
    echo -e "${GREEN}PASSED${NC}"
fi

echo ""

# Check for existing review approval
REVIEW_FILE="hooks/reviews/pending-approval.json"
APPROVED=false

if [ -f "$REVIEW_FILE" ]; then
    # Check if the review covers all staged files and is approved
    REVIEW_VERDICT=$(cat "$REVIEW_FILE" 2>/dev/null | grep -o '"verdict":\s*"[^"]*"' | cut -d'"' -f4 || echo "")
    if [ "$REVIEW_VERDICT" = "APPROVED" ]; then
        echo -e "${GREEN}Found approved review in $REVIEW_FILE${NC}"
        APPROVED=true
    fi
fi

# Summary
echo -e "${BLUE}========================================${NC}"
echo -e "SUMMARY: ${RED}$ERRORS errors${NC}, ${YELLOW}$WARNINGS warnings${NC}"
echo -e "${BLUE}========================================${NC}"
echo ""

# If approved, allow commit even with errors (reviewer made explicit decision)
if [ "$APPROVED" = true ]; then
    if [ $ERRORS -gt 0 ]; then
        echo -e "${YELLOW}Errors found but APPROVED by review - allowing commit${NC}"
    fi
    echo -e "${GREEN}Pre-commit checks passed (approved)${NC}"
    exit 0
fi

if [ $ERRORS -gt 0 ]; then
    echo -e "${RED}COMMIT BLOCKED${NC}"
    echo ""
    echo -e "Fix the errors above, or if this is intentional:"
    echo -e "  1. Get review approval: create ${YELLOW}hooks/reviews/pending-approval.json${NC}"
    echo -e "     with ${GREEN}\"verdict\": \"APPROVED\"${NC}"
    echo -e "  2. Or bypass with: ${YELLOW}git commit --no-verify${NC} (not recommended)"
    echo ""
    exit 1
fi

if [ $WARNINGS -gt 0 ]; then
    echo -e "${YELLOW}WARNINGS PRESENT - Review recommended${NC}"
    echo ""
    echo -e "Proceeding with commit. Consider running full layer review."
fi

echo -e "${GREEN}Pre-commit checks passed${NC}"
exit 0
