#!/bin/bash
#
# Pre-push hook for Neuro-Engine
# Final gate before pushing engine infrastructure changes
#
# Install: git config core.hooksPath githooks
#

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Protected paths
PROTECTED_PATHS=(
    "Packages/com.neuroengine.core/Runtime/Core/"
    "Packages/com.neuroengine.core/Runtime/Services/"
    "Packages/com.neuroengine.core/Editor/"
    "Packages/com.neuroengine.core/Tests/"
)

# Read push info
remote="$1"
url="$2"

# Get commits being pushed
while read local_ref local_sha remote_ref remote_sha; do
    if [ "$local_sha" = "0000000000000000000000000000000000000000" ]; then
        # Branch deletion, skip
        continue
    fi

    if [ "$remote_sha" = "0000000000000000000000000000000000000000" ]; then
        # New branch, check all commits
        range="$local_sha"
    else
        # Existing branch, check new commits only
        range="$remote_sha..$local_sha"
    fi

    # Get files changed in this push
    CHANGED_FILES=$(git diff --name-only $range 2>/dev/null || git diff-tree --no-commit-id --name-only -r $local_sha)

    # Check for protected paths
    PROTECTED_CHANGES=()
    for file in $CHANGED_FILES; do
        for path in "${PROTECTED_PATHS[@]}"; do
            if [[ "$file" == $path* ]]; then
                PROTECTED_CHANGES+=("$file")
                break
            fi
        done
    done

    if [ ${#PROTECTED_CHANGES[@]} -gt 0 ]; then
        echo -e "${BLUE}========================================${NC}"
        echo -e "${YELLOW}ENGINE LAYER PUSH REVIEW${NC}"
        echo -e "${BLUE}========================================${NC}"
        echo ""
        echo -e "Pushing to: ${BLUE}$remote${NC} ($url)"
        echo -e "Branch: ${BLUE}$remote_ref${NC}"
        echo ""
        echo -e "Protected engine files in this push:"
        for file in "${PROTECTED_CHANGES[@]}"; do
            echo -e "  ${YELLOW}$file${NC}"
        done
        echo ""

        # Check for review file
        REVIEW_DIR="hooks/reviews"
        LATEST_REVIEW=""

        if [ -d "$REVIEW_DIR" ]; then
            LATEST_REVIEW=$(ls -t "$REVIEW_DIR"/layer-review-*.json 2>/dev/null | head -1 || true)
        fi

        if [ -n "$LATEST_REVIEW" ]; then
            REVIEW_VERDICT=$(cat "$LATEST_REVIEW" | grep -o '"verdict":\s*"[^"]*"' | cut -d'"' -f4 || echo "UNKNOWN")
            REVIEW_TIME=$(cat "$LATEST_REVIEW" | grep -o '"timestamp":\s*"[^"]*"' | cut -d'"' -f4 || echo "unknown")

            echo -e "Latest review: ${BLUE}$LATEST_REVIEW${NC}"
            echo -e "  Verdict: ${YELLOW}$REVIEW_VERDICT${NC}"
            echo -e "  Time: $REVIEW_TIME"
            echo ""

            if [ "$REVIEW_VERDICT" = "BLOCKED" ]; then
                echo -e "${RED}PUSH BLOCKED${NC}"
                echo -e "Latest review verdict is BLOCKED. Fix issues before pushing."
                echo ""
                echo -e "To bypass (not recommended): ${YELLOW}git push --no-verify${NC}"
                exit 1
            elif [ "$REVIEW_VERDICT" = "CHANGES_REQUESTED" ]; then
                echo -e "${YELLOW}WARNING: Review requested changes${NC}"
                echo -e "Consider addressing feedback before pushing."
                echo ""
                read -p "Continue anyway? [y/N] " -n 1 -r
                echo
                if [[ ! $REPLY =~ ^[Yy]$ ]]; then
                    exit 1
                fi
            elif [ "$REVIEW_VERDICT" = "APPROVED" ]; then
                echo -e "${GREEN}Review APPROVED - Push allowed${NC}"
            fi
        else
            echo -e "${YELLOW}WARNING: No layer review found${NC}"
            echo ""
            echo -e "Engine infrastructure changes should be reviewed."
            echo -e "Run: ${BLUE}review-layers skill${NC} or create review in hooks/reviews/"
            echo ""

            # Allow push but warn
            echo -e "${YELLOW}Proceeding without review...${NC}"
        fi

        echo -e "${BLUE}========================================${NC}"
    fi
done

exit 0
